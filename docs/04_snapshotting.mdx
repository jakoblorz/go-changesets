---
title: Snapshot Releases (Release Candidates)
description: Create RC tags and GitHub pre-releases without touching version files.
---

# Snapshot Releases (Release Candidates)

Snapshot releases allow you to test changes before officially releasing them. They create **release candidate (RC) tags** and GitHub pre-releases without modifying any files in your repository.

## What are Snapshots?

Snapshots are **pre-release versions** that let you:
- Test changes in a production-like environment
- Share builds with QA, stakeholders, or beta testers
- Iterate on features before final release
- Validate releases on canary branches

**Key characteristic:** Snapshots create git tags and GitHub releases but **do not** modify `version.txt`, `CHANGELOG.md`, or delete changesets.

## Release Candidate Format

Snapshots use the `-rc{N}` suffix format:

```
auth@v1.2.0-rc0   # First release candidate
auth@v1.2.0-rc1   # Second RC (after fixes)
auth@v1.2.0-rc2   # Third RC (after more fixes)
auth@v1.2.0       # Final release (after testing)
```

**RC number increments automatically** each time you create a snapshot for the same version.

## How Snapshots Work

### 1. Calculate Next Version (In-Memory Only)

Snapshots calculate what the next version would be based on pending changesets:

```bash
# Current state:
# - version.txt: 1.1.0
# - Latest tag: auth@v1.1.0
# - Changesets: 2√ó minor bumps

# Snapshot calculates:
# Next version: 1.2.0 (based on changesets)
```

**Important:** This calculation happens **in-memory only**. No files are modified.

### 2. Find Next RC Number

Snapshots check for existing RC tags on the current branch:

```bash
# Existing tags on this branch:
auth@v1.2.0-rc0
auth@v1.2.0-rc1

# Next snapshot creates:
auth@v1.2.0-rc2
```

**Branch-aware:** Only looks at tags reachable from current branch (via git ancestry).

### 3. Create Git Tag and GitHub Pre-Release

```bash
# Creates:
# - Git tag: auth@v1.2.0-rc2
# - GitHub pre-release with changelog preview
# - Does NOT modify version.txt or CHANGELOG.md
# - Does NOT delete changesets
```

## Creating Snapshots

### Command Usage

**For a specific project:**
```bash
export GITHUB_TOKEN=your_token

changeset snapshot --project auth --owner yourorg --repo yourrepo
```

**For all projects with changesets:**
```bash
changeset each --filter open-changesets -- \
  changeset snapshot --owner yourorg --repo yourrepo
```

**Via STDIN (from `changeset each`):**
```bash
# Each command automatically provides project context
changeset each --filter open-changesets -- changeset snapshot --owner org --repo repo
```

### Command Output

```bash
$ changeset snapshot --project auth --owner acme --repo monorepo

üì¶ Creating snapshot for auth

Found 2 changeset(s):
  - dazzling_mouse_abc123 (minor)
  - cheerful_panda_def456 (patch)

Current version: 1.1.0
Latest tag: auth@v1.1.0
Calculated next version: 1.2.0 (based on changesets)

Latest RC: auth@v1.2.0-rc1
New snapshot tag: auth@v1.2.0-rc2

‚úì Created tag: auth@v1.2.0-rc2
‚úì Pushed tag to remote
‚úì Created GitHub pre-release

üéâ Snapshot created: auth@v1.2.0-rc2
Release URL: https://github.com/acme/monorepo/releases/tag/auth@v1.2.0-rc2
```

## Typical Canary Workflow

This is the recommended workflow for teams that need to test releases before merging to main:

### 1. Create Canary Branch

```bash
# Start from main
git checkout main
git pull origin main

# Create canary branch
git checkout -b canary
git push origin canary
```

### 2. Merge Feature Branches to Canary

```bash
# Developer has feature branch with changesets
git checkout canary
git merge feature/oauth2  # Has changesets
git push origin canary
```

### 3. Create First Snapshot (RC0)

**Via GitHub Actions UI:**
```
Actions > Release Candidate Snapshot > Run workflow
  Branch: canary
  Project: (leave empty for all)
```

**Or manually:**
```bash
git checkout canary

export GITHUB_TOKEN=your_token
changeset snapshot --project auth --owner yourorg --repo yourrepo
# Creates: auth@v1.2.0-rc0
```

### 4. Test the RC Build

```bash
# QA team tests the RC
go get github.com/yourorg/yourrepo/packages/auth@v1.2.0-rc0

# Run integration tests
# Perform manual QA
```

### 5. Fix Issues and Create RC1

If issues are found:

```bash
# Fix on feature branch
git checkout feature/oauth2
vim packages/auth/handler.go  # Fix issues
git commit -m "fix: handle edge case in OAuth2"
git push origin feature/oauth2

# Merge fixes to canary
git checkout canary
git merge feature/oauth2
git push origin canary

# Create new snapshot
changeset snapshot --project auth --owner yourorg --repo yourrepo
# Creates: auth@v1.2.0-rc1 (incremented!)
```

**Repeat** as needed: rc2, rc3, etc.

### 6. Merge to Main (Final Release)

Once testing passes:

```bash
# Merge canary to main
git checkout main
git merge canary
git push origin main

# Normal version PR workflow takes over:
# 1. CI creates version PR with version.txt and CHANGELOG.md updates
# 2. You review and merge the version PR
# 3. CI publishes final release: auth@v1.2.0 (no -rc suffix)
```

## Git Ancestry and Branch Awareness

Snapshots are **branch-aware** using git tag ancestry. This prevents conflicts when working with multiple branches.

### How Git Ancestry Works

```
main:   v1.2.0 ‚îÄ‚îÄ‚Üí v1.3.0 ‚îÄ‚îÄ‚Üí v1.4.0
         ‚îÇ
         ‚îî‚îÄ‚îÄ‚Üí canary: (new commits with changesets)
```

**On canary branch:**
```bash
changeset snapshot --project auth --owner org --repo repo

# Sees: v1.2.0 (last tag on this branch)
# Does NOT see: v1.3.0, v1.4.0 (not ancestors of canary)
# Calculates next version based on changesets from v1.2.0
```

**Why this matters:**

‚úÖ **Prevents conflicts** - Canary doesn't see tags created after it branched  
‚úÖ **Predictable versioning** - Based on branch history only  
‚úÖ **Safe parallel development** - Main and canary can have different RCs

### Example Scenario

**Main branch releases:**
```bash
main: v1.2.0 ‚Üí v1.3.0 (published)
```

**Canary branch (branched from v1.2.0):**
```bash
canary: v1.2.0 ‚Üí (changesets added)

# First snapshot
changeset snapshot  # Creates: v1.3.0-rc0
# (Based on changesets from v1.2.0, not v1.3.0)

# After merging main into canary
git merge main  # Now includes v1.3.0

# Next snapshot
changeset snapshot  # Creates: v1.4.0-rc0
# (Now based on v1.3.0 as the base)
```

## Snapshots vs Final Releases

| Aspect | Snapshot (RC) | Final Release |
|--------|---------------|---------------|
| **Tag format** | `project@v1.2.0-rc0` | `project@v1.2.0` |
| **GitHub release** | Pre-release ‚úì | Regular release |
| **Modifies version.txt** | ‚ùå No | ‚úÖ Yes |
| **Modifies CHANGELOG.md** | ‚ùå No | ‚úÖ Yes |
| **Deletes changesets** | ‚ùå No | ‚úÖ Yes |
| **Can be repeated** | ‚úÖ Yes (rc1, rc2...) | ‚ùå No |
| **Purpose** | Testing | Production |

## CI/CD Integration

### Manual Snapshot Workflow

Create `.github/workflows/snapshot.yml`:

```yaml
name: Release Candidate Snapshot

on:
  workflow_dispatch:
    inputs:
      project:
        description: 'Project name (leave empty for all projects with changesets)'
        required: false
        type: string
      branch:
        description: 'Branch to create snapshot from'
        required: false
        default: 'canary'
        type: string

permissions:
  contents: write

jobs:
  snapshot:
    name: Create Snapshot
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}
          fetch-depth: 0  # Need full history for git ancestry

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.24"

      - name: Install go-changeset
        run: go install github.com/jakoblorz/go-changesets/cmd/changeset@latest

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create Snapshot
        run: |
          if [ -z "${{ inputs.project }}" ]; then
            # All projects with changesets
            changeset each --filter open-changesets -- \
              changeset snapshot \
                --owner ${{ github.repository_owner }} \
                --repo ${{ github.event.repository.name }}
          else
            # Specific project
            changeset snapshot \
              --project "${{ inputs.project }}" \
              --owner ${{ github.repository_owner }} \
              --repo ${{ github.event.repository.name }}
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        run: |
          echo "## üöÄ Snapshot Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Release candidate snapshot has been created." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "View pre-releases: https://github.com/${{ github.repository }}/releases" >> $GITHUB_STEP_SUMMARY
```

### Triggering Snapshots

**Via GitHub UI:**
```
1. Go to Actions tab
2. Select "Release Candidate Snapshot"
3. Click "Run workflow"
4. Choose:
   - Branch: canary (or your test branch)
   - Project: (leave empty for all, or specify one)
5. Click "Run workflow"
```

**Result:**
- RC tag created on specified branch
- GitHub pre-release appears in Releases page
- No files modified (changesets remain for final release)

## Use Cases

### 1. Feature Branch Testing

Test a feature before merging to main:

```bash
# On feature branch
git checkout feature/new-api
changeset add  # Add changesets

# Create snapshot to test
changeset snapshot --project api --owner org --repo repo
# Creates: api@v0.5.0-rc0

# Share with testers
# "Hey team, test api@v0.5.0-rc0"

# Fix issues, create rc1, rc2...

# When ready, merge to main
# Final release happens via normal workflow
```

### 2. Canary Releases

Test in production with subset of users:

```bash
# Deploy RC to canary environment
kubectl set image deployment/api api=ghcr.io/org/api:v0.5.0-rc0

# Monitor metrics, logs, errors
# If issues found, fix and create rc1

# When stable, promote to production
# Merge to main ‚Üí final v0.5.0 release
```

### 3. Beta Testing Program

Share pre-releases with beta users:

```bash
# Create snapshot
changeset snapshot --project cli --owner org --repo repo

# Beta users install:
go install github.com/org/repo/packages/cli@v2.0.0-rc0

# Collect feedback
# Fix issues ‚Üí rc1 ‚Üí more feedback ‚Üí rc2

# Final release when feedback is positive
```

### 4. QA Approval Gates

Require QA sign-off before production:

```bash
# Dev team creates RC
changeset snapshot --project auth --owner org --repo repo
# Tag: auth@v1.5.0-rc0

# QA tests RC build
# QA approves: ‚úÖ Ready for production

# Merge to main ‚Üí version PR ‚Üí final release
```

## Advanced Topics

### Multiple Projects in One Snapshot

```bash
# Create RCs for all projects with changesets
changeset each --filter open-changesets -- \
  changeset snapshot --owner org --repo repo

# Creates:
# - auth@v1.2.0-rc0
# - api@v2.1.0-rc0
# - shared@v0.3.0-rc0
```

### Snapshot from Different Branches

Snapshots are branch-specific due to git ancestry:

```bash
# On main branch
git checkout main
changeset snapshot --project auth --owner org --repo repo
# Base version: Latest tag on main

# On canary branch
git checkout canary
changeset snapshot --project auth --owner org --repo repo
# Base version: Latest tag reachable from canary
# (May be different from main!)
```

### Skipping Snapshots

If you decide a snapshot isn't needed:

**Option 1: Don't create it**
- Simply don't run the snapshot command
- Changesets remain for final release

**Option 2: Delete the RC tag**
```bash
# Delete locally and remotely
git tag -d auth@v1.2.0-rc0
git push origin :refs/tags/auth@v1.2.0-rc0

# Delete GitHub pre-release
# (Via GitHub UI: Releases > Delete)
```

## Snapshots vs Final Releases

### What Snapshots DON'T Do

‚ùå **Don't modify version.txt**
```bash
# Before snapshot
cat packages/auth/version.txt  # 1.1.0

# After snapshot (auth@v1.2.0-rc0)
cat packages/auth/version.txt  # 1.1.0 (unchanged!)
```

‚ùå **Don't modify CHANGELOG.md**
```bash
# Changesets remain
ls .changeset/
# dazzling_mouse_abc123.md (still there)
```

‚ùå **Don't delete changesets**
- Changesets remain in `.changeset/` directory
- Will be consumed when you run `changeset version`
- Final release uses the same changesets

### What Final Releases DO

After testing snapshots, merge to main and run normal version workflow:

‚úÖ **Update version.txt** ‚Üí `1.2.0`  
‚úÖ **Update CHANGELOG.md** ‚Üí Adds entries from changesets  
‚úÖ **Delete changesets** ‚Üí Consumed changesets removed  
‚úÖ **Create tag** ‚Üí `auth@v1.2.0` (no -rc suffix)  
‚úÖ **GitHub release** ‚Üí Regular release (not pre-release)

## Complete Canary Example

Here's a step-by-step walkthrough of a complete canary release:

### Step 1: Create Canary Branch

```bash
git checkout main
git pull origin main
git checkout -b canary
git push origin canary
```

### Step 2: Add Features with Changesets

```bash
# Developer works on feature
git checkout -b feature/rate-limiting

vim packages/api/middleware.go  # Implement rate limiting

changeset add
# Select: api
# Bump: minor
# Message: "Add configurable rate limiting middleware"

git add .
git commit -m "feat: add rate limiting"
git push origin feature/rate-limiting

# Merge feature to canary
git checkout canary
git merge feature/rate-limiting
git push origin canary
```

### Step 3: Create First Snapshot

**Via GitHub Actions:**
```
Actions > Release Candidate Snapshot > Run workflow
  Branch: canary
  Project: api
```

**Or locally:**
```bash
git checkout canary
changeset snapshot --project api --owner yourorg --repo yourrepo
```

**Result:**
```
Created snapshot: api@v0.4.0-rc0
Release URL: https://github.com/yourorg/yourrepo/releases/tag/api@v0.4.0-rc0
```

### Step 4: Deploy and Test

```bash
# Deploy RC to staging/canary environment
docker pull ghcr.io/yourorg/api:v0.4.0-rc0
kubectl set image deployment/api api=ghcr.io/yourorg/api:v0.4.0-rc0

# Run automated tests
go test ./... -v

# Manual QA testing
# Load testing
# Security scanning
```

### Step 5: Fix Issues (if found)

```bash
# Issues discovered in testing
git checkout feature/rate-limiting
vim packages/api/middleware.go  # Fix issues
git commit -m "fix: handle zero rate limit correctly"
git push origin feature/rate-limiting

# Merge fix to canary
git checkout canary
git merge feature/rate-limiting
git push origin canary

# Create rc1
changeset snapshot --project api --owner yourorg --repo yourrepo
# Creates: api@v0.4.0-rc1

# Test again
```

**Repeat** until all issues are resolved (rc2, rc3, etc.)

### Step 6: Promote to Production

When testing passes:

```bash
# Merge canary to main
git checkout main
git merge canary --no-ff  # Create merge commit
git push origin main
```

**Automatic workflow triggers:**
```
1. CI detects changesets on main
2. CI creates version PR:
   - Updates version.txt ‚Üí 0.4.0
   - Updates CHANGELOG.md
   - Deletes changesets
3. You review and merge version PR
4. CI publishes final release: api@v0.4.0
```

### Step 7: Final Release Published

```
GitHub Release created: api@v0.4.0
- Regular release (not pre-release)
- Contains all changelog entries from changesets
- RC tags remain as historical record
```

**Users can now install:**
```bash
go get github.com/yourorg/yourrepo/packages/api@v0.4.0
```

## Branch-Specific Snapshots

### Scenario: Parallel Development

```
main:   v1.2.0 ‚îÄ‚îÄ‚Üí v1.3.0 (new feature merged)
         ‚îÇ
         ‚îî‚îÄ‚îÄ‚Üí canary: (different feature being tested)
```

**On main branch:**
- Latest tag: `auth@v1.3.0`
- Snapshot would create: `auth@v1.4.0-rc0`

**On canary branch:**
- Latest tag: `auth@v1.2.0` (canary doesn't see v1.3.0)
- Snapshot would create: `auth@v1.3.0-rc0`

**No conflict!** Different branches can have different RC versions because they're based on different tag ancestry.

### Keeping Canary in Sync

To base canary snapshots on latest main:

```bash
# Merge main into canary periodically
git checkout canary
git merge main
git push origin canary

# Now snapshots see latest main tags
changeset snapshot --project auth --owner org --repo repo
# Uses latest version from main as base
```

## Cleanup and Maintenance

### Deleting Old RC Tags

RC tags accumulate over time. Clean them up after final release:

```bash
# List RC tags for a project
git tag -l "auth@v*-rc*"

# Delete local and remote RC tags for a version
git tag -d auth@v1.2.0-rc0 auth@v1.2.0-rc1 auth@v1.2.0-rc2
git push origin --delete auth@v1.2.0-rc0 auth@v1.2.0-rc1 auth@v1.2.0-rc2
```

**Or keep them** as historical record of testing iterations.

### Deleting GitHub Pre-Releases

```
GitHub > Releases > Pre-releases
  ‚Üí Click on RC release
  ‚Üí Delete release (keeps tag)
  ‚Üí Or delete both release and tag
```

## Troubleshooting

### "No changesets found for this project"

**Cause:** No changesets exist for the project

**Solution:**
```bash
# Check for changesets
ls .changeset/

# Project needs changesets to create snapshot
changeset add  # Create changesets first
```

### RC number not incrementing

**Cause:** Not on the same branch as previous RCs

**Solution:**
```bash
# Check existing RC tags on current branch
git tag -l "auth@v*-rc*" --merged HEAD

# Make sure you're on the right branch
git checkout canary
```

### Snapshot creates wrong version number

**Cause:** Git ancestry showing different base version than expected

**Solution:**
```bash
# Check what tags are reachable from current branch
git tag -l "auth@v*" --merged HEAD | sort -V | tail -5

# If needed, merge in latest tags from main
git merge main
```

### "GitHub release already exists"

**Cause:** RC tag already created

**Solution:**
```bash
# Check existing releases
gh release list

# Snapshot will increment to next RC number
# If you want to replace, delete the old one first
gh release delete auth@v1.2.0-rc0 --yes
git tag -d auth@v1.2.0-rc0
git push origin --delete auth@v1.2.0-rc0
```

## Best Practices

### 1. Use Dedicated Canary Branch

‚úÖ **Good:**
```bash
# Dedicated canary branch for RC testing
git checkout -b canary
```

‚ùå **Bad:**
```bash
# Creating RCs from main branch
# Blocks other features from being merged
```

### 2. Clean Up After Release

```bash
# After final release (auth@v1.2.0), delete RC tags
git tag -d auth@v1.2.0-rc{0,1,2}
git push origin --delete auth@v1.2.0-rc{0,1,2}
```

### 3. Document RC Testing Results

```markdown
# In PR description or release notes
RC Testing:
- rc0: Initial build (failed - memory leak found)
- rc1: Memory leak fixed (failed - performance regression)
- rc2: Performance optimized (passed QA ‚úÖ)
```

### 4. Use Semantic Branch Names

```bash
‚úÖ Good: canary, staging, qa, release-candidate
‚ùå Bad: test, temp, branch1
```

### 5. Automate RC Creation

Use GitHub Actions workflow_dispatch for easy RC creation via UI - no local commands needed.

## Examples

### Quick RC Test

```bash
# Quick test before merging to main
git checkout feature/new-feature
changeset add
changeset snapshot --project auth --owner org --repo repo

# Test the RC build
# If good, merge to main
# If issues, fix and create rc1
```

### Multi-Project RC

```bash
# Test multiple projects together
changeset each --filter open-changesets -- \
  changeset snapshot --owner org --repo repo

# Creates:
# - auth@v1.2.0-rc0
# - api@v2.0.0-rc0
# - shared@v0.5.0-rc0

# Test all three together in staging
```

### Hotfix RC

```bash
# Critical bug fix needs testing
git checkout -b hotfix/auth-security
vim packages/auth/handler.go  # Fix security issue

changeset add  # Bump: patch

# Create RC for testing
changeset snapshot --project auth --owner org --repo repo
# Tag: auth@v1.2.1-rc0

# Security team validates fix
# If approved, fast-track to main
```

## Next Steps

- Learn about [GitHub Actions integration](./github-integration.mdx) for automated snapshots
- See the [kitchensink example](../kitchensink/.github/workflows/snapshot.yml) for a complete workflow
- Read about [final releases](./intro-to-using-changesets.mdx) and the version/publish workflow
