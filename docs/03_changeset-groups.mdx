---
title: Changeset Groups and Relationships
description: Understand changesets created together and coordinate releases.
---

# Changeset Groups and Relationships

When a single feature affects multiple projects in your monorepo, understanding which changesets are related is crucial for coordinated releases. This guide explains how changeset grouping works and best practices for creating related changesets.

## What are Changeset Groups?

A **changeset group** is a collection of changesets that were created together in the same git commit. These changesets are considered **related** because they represent different parts of the same feature or change.

### Why Groups Matter

When you have related changesets across multiple projects, you typically want to:

âœ… **Review them together** - Understand the full scope of a feature  
âœ… **Merge them together** - Avoid partial releases that could break functionality  
âœ… **Coordinate timing** - Release all related projects simultaneously  
âœ… **Track dependencies** - Know which projects are coupled in a change

**Without grouping:**
```
Opens PR #123 (auth v1.2.0)
No context â†’ merges alone
Later: PR #124 (api v2.1.0) still open
Result: API breaks because auth released without corresponding API changes âŒ
```

**With grouping:**
```
Opens PR #123 (auth v1.2.0)
Sees: "Related to #124 and #125"
Reviews all three together
Merges all three at once
Result: Complete feature released cohesively âœ…
```

## How Grouping Works

`go-changeset` uses **git commit history** to determine relationships:

```bash
# When you run:
changeset tree

# It analyzes each changeset file:
git log --follow --diff-filter=A --pretty=format:"%H" -1 .changeset/oauth-auth.md
# â†’ e810ecb51bbded25f24faf9fe3da368fc01fcef7

git log --follow --diff-filter=A --pretty=format:"%H" -1 .changeset/oauth-api.md
# â†’ e810ecb51bbded25f24faf9fe3da368fc01fcef7

# Same commit SHA â†’ related changesets!
```

**Key Point:** Changesets created in the same git commit are automatically grouped.

## Creating Related Changesets

There are **two main approaches** to creating changeset groups:

### Approach 1: Manual Multi-Project Changesets (Recommended)

Use the `changeset add` interactive TUI to select multiple projects at once:

```bash
git checkout -b feature/oauth2

# Make changes to multiple projects
vim packages/auth/oauth.go
vim packages/api/oauth_handler.go
vim packages/shared/oauth_types.go

# Create changesets for all affected projects
changeset add
# Select: auth, api, shared (use space to toggle)
# Bump: minor (applies to all)
# Message: "Add OAuth2 authentication support"

# All changesets created at once
git add .changeset/
git commit -m "feat: add OAuth2 support"
# Result: 3 changesets in ONE commit â†’ automatically grouped! âœ…
```

**Created files (all in same commit):**
```
.changeset/
â”œâ”€ dazzling_mouse_abc123.md (auth: minor)
â”œâ”€ cheerful_panda_def456.md (api: minor)
â””â”€ wise_owl_ghi789.md (shared: patch)
```

**Benefits:**
- âœ… Simple and straightforward
- âœ… Clear intent - selected together = related
- âœ… One commit = automatic grouping
- âœ… Works immediately

---

### Approach 2: Squash Merging Feature PRs (Automatic)

Create changesets separately during development, then squash when merging to main:

```bash
# Developer adds changesets over multiple commits
git checkout -b feature/oauth2

# Commit 1: auth changes
vim packages/auth/oauth.go
changeset add  # Select: auth
git commit -m "feat(auth): add OAuth2"

# Commit 2: api changes  
vim packages/api/oauth_handler.go
changeset add  # Select: api
git commit -m "feat(api): add OAuth2 endpoints"

# Commit 3: shared types
vim packages/shared/oauth_types.go
changeset add  # Select: shared
git commit -m "feat(shared): add OAuth2 types"

# Push and create PR
git push origin feature/oauth2
gh pr create --title "Add OAuth2 support"

# When merging, use SQUASH merge (GitHub default)
# Result: All 3 changesets squashed into ONE commit on main! âœ…
```

**Git history on feature branch:**
```
feature/oauth2:
  â”œâ”€ commit1: auth changeset created
  â”œâ”€ commit2: api changeset created
  â””â”€ commit3: shared changeset created
```

**Git history after squash merge to main:**
```
main:
  â””â”€ commit abc1234: All 3 changesets created together
```

**Benefits:**
- âœ… Natural workflow during development
- âœ… Automatic grouping via squash merge
- âœ… Clean history on main
- âœ… No manual coordination needed

---

## Viewing Changeset Groups

### Using `changeset tree`

The `tree` command shows you which changesets are related:

```bash
# View relationships before creating release PRs
changeset tree --filter open-changesets
```

**Output:**
```
ðŸ“Š Changeset Relationship Tree

Commit: e810ecb (feat: add OAuth2 support)
â”œâ”€ auth (1 changeset(s))
â”‚  â””â”€ dazzling_mouse_abc123.md (minor) - Add OAuth2 support
â”œâ”€ api (1 changeset(s))
â”‚  â””â”€ cheerful_panda_def456.md (minor) - Add OAuth2 endpoints
â””â”€ shared (1 changeset(s))
   â””â”€ wise_owl_ghi789.md (patch) - Update OAuth2 types

Commit: a1b2c3d (fix: memory leak)
â””â”€ cli (1 changeset(s))
   â””â”€ brave_fox_jkl345.md (patch) - Fix memory leak in CLI

Summary:
- 2 commit group(s)
- 4 project(s) affected
- 4 total changeset(s)
```

**Interpretation:**
- **Group 1:** 3 changesets from commit `e810ecb` (OAuth2 feature across auth/api/shared)
- **Group 2:** 1 changeset from commit `a1b2c3d` (standalone CLI fix)

**Action:**
- Merge PRs for auth, api, and shared **together** (related)
- Merge CLI PR **independently** (unrelated)

### JSON Output for CI

```bash
changeset tree --format json > tree.json
cat tree.json | jq '.groups[0].projects[].name'
# Output:
# "auth"
# "api"
# "shared"
```

**Use in CI:**
```yaml
- name: Show relationships
  run: |
    echo "## Changeset Groups" >> $GITHUB_STEP_SUMMARY
    changeset tree --filter open-changesets >> $GITHUB_STEP_SUMMARY
```

---

## Best Practices

### 1. Use Squash Merge for Feature PRs

**GitHub Settings:**
```
Settings > General > Pull Requests
âœ… Allow squash merging
âŒ Allow merge commits (optional - creates multiple commits)
âŒ Allow rebase merging (optional - preserves individual commits)
```

**Why squash merge?**
- âœ… All changesets grouped automatically on main
- âœ… Clean linear history
- âœ… One commit = one feature = one group
- âœ… No manual coordination needed

**Example:**
```bash
# Feature PR has 10 commits with 3 changesets scattered throughout
# Squash merge â†’ 1 commit on main â†’ 3 changesets in one group âœ…
```

### 2. Create Multi-Project Changesets Together

When you know changes affect multiple projects:

```bash
# âœ… Good: Select all at once
changeset add
# Select: auth, api, shared
# One commit â†’ automatically grouped

# âŒ Avoid: Multiple separate commits
changeset add  # Only auth
git commit -m "auth part"

changeset add  # Only api  
git commit -m "api part"

changeset add  # Only shared
git commit -m "shared part"

# Result: 3 commits â†’ 3 separate groups â†’ NOT related!
# Fix: Squash merge when merging PR
```

### 3. Coordinate Review for Grouped Changes

When release PRs are created with relationships:

```bash
# PR #123 shows:
# Related to #124 and #125

# âœ… Good workflow:
1. Review PR #123 (auth)
2. Review PR #124 (api)  
3. Review PR #125 (shared)
4. Merge all three together (or in quick succession)

# âŒ Bad workflow:
1. Merge PR #123 alone
2. Deploy to production
3. API breaks because #124 not merged yet
```

### 4. Use Descriptive Commit Messages

Commit messages appear in the tree output:

```bash
# âœ… Good:
git commit -m "feat: add OAuth2 authentication support"

# Tree shows:
# Commit: e810ecb (feat: add OAuth2 authentication support)

# âŒ Bad:
git commit -m "updates"

# Tree shows:
# Commit: e810ecb (updates)  # Not helpful!
```

### 5. Check Tree Before Creating Release PRs

```bash
# In your workflow or manually:
changeset tree --filter open-changesets

# Review output:
# - How many groups?
# - Which projects in each group?
# - Are groupings correct?

# If unexpected grouping:
# - Check git log
# - Verify squash merge was used
# - Look for manual commits to .changeset/
```

---

## Common Scenarios

### Scenario 1: Single Feature, Multiple Projects

**Setup:**
```bash
Feature: Add distributed caching
Affects: api (cache client), shared (cache interface), worker (cache backend)
```

**Workflow:**
```bash
git checkout -b feature/caching

# Option A: Create all changesets at once
changeset add
# Select: api, shared, worker
# One commit â†’ grouped âœ…

# Option B: Create changesets separately during development
changeset add  # api
# ... more commits ...
changeset add  # shared
# ... more commits ...
changeset add  # worker

# When merging: Use squash merge â†’ grouped âœ…
```

**Result:**
```
Commit: abc1234 (feat: add distributed caching)
â”œâ”€ api (1 changeset)
â”œâ”€ shared (1 changeset)
â””â”€ worker (1 changeset)

Release PRs created:
- #101 Release api v1.3.0 (linked to #102, #103)
- #102 Release shared v0.5.0 (linked to #101, #103)
- #103 Release worker v2.0.0 (linked to #101, #102)

Action: Review and merge all three together
```

---

### Scenario 2: Independent Bug Fixes

**Setup:**
```bash
Bug Fix 1: Memory leak in auth
Bug Fix 2: Validation error in api
(Two separate, unrelated issues)
```

**Workflow:**
```bash
# Fix 1
git checkout -b fix/auth-leak
changeset add  # Select: auth
git commit -m "fix: memory leak in auth"
# Merge PR (squash)

# Fix 2  
git checkout -b fix/api-validation
changeset add  # Select: api
git commit -m "fix: validation in api"
# Merge PR (squash)
```

**Result:**
```
Commit: abc1234 (fix: memory leak in auth)
â””â”€ auth (1 changeset)

Commit: def5678 (fix: validation in api)
â””â”€ api (1 changeset)

Release PRs created:
- #101 Release auth v1.2.1 (no related PRs)
- #102 Release api v2.0.1 (no related PRs)

Action: Each can be reviewed and merged independently
```

---

### Scenario 3: Mixed - Some Related, Some Not

**Setup:**
```bash
PR 1: OAuth2 feature (auth + api + shared)
PR 2: Unrelated CLI improvement
```

**Workflow:**
```bash
# PR 1: Multi-project feature
git checkout -b feature/oauth2
changeset add  # Select: auth, api, shared
git commit -m "feat: add OAuth2"
# Squash merge â†’ all grouped

# PR 2: Independent change
git checkout -b feat/cli-colors
changeset add  # Select: cli
git commit -m "feat: add colors to CLI"
# Squash merge â†’ separate group
```

**Result:**
```
Commit: abc1234 (feat: add OAuth2)
â”œâ”€ auth (1 changeset) â† Group 1
â”œâ”€ api (1 changeset)  â† Group 1
â””â”€ shared (1 changeset) â† Group 1

Commit: def5678 (feat: add colors to CLI)
â””â”€ cli (1 changeset) â† Group 2 (independent)

Release PRs:
- #101, #102, #103 (linked - merge together)
- #104 (independent - merge whenever ready)
```

---

## GitHub Workflow Integration

The kitchensink example includes automatic PR linking:

### How It Works

**Step 1: Analyze (before versioning)**
```yaml
- name: Analyze changeset relationships
  run: |
    # Capture relationships BEFORE changeset files are deleted
    changeset tree --filter open-changesets --format json > /tmp/tree.json
    
    # Show in workflow logs
    changeset tree --filter open-changesets
```

**Step 2: Create PRs**
```yaml
- name: Create per-project PRs
  run: |
    changeset each --filter open-changesets -- sh -c '
      # Create PR with placeholder
      gh pr create --body "...<!-- RELATED_PRS_PLACEHOLDER -->..."
      
      # Save PR number
      echo "$PROJECT=$PR_NUM" >> /tmp/pr-mapping.txt
    '
```

**Step 3: Link PRs**
```yaml
- name: Link related PRs
  run: |
    # Parse tree.json, update each PR with links to related PRs
    jq -c '.groups[]' /tmp/tree.json | while read -r group; do
      # For each group with multiple projects:
      # - Build list of related PRs
      # - Update each PR body with relationship section
    done
```

### What Reviewers See

**PR #123 (auth):**
```markdown
## ðŸ“‹ Changes

### Minor Changes
- Add OAuth2 authentication support

## ðŸ”— Related Release PRs

This release is part of a coordinated change from commit [`e810ecb`]:
- #123 Release auth v1.2.0 â† **You are here**
- #124 Release api v2.1.0
- #125 Release shared v0.3.1

**ðŸ’¡ Tip:** These changes were made together. Consider reviewing and merging all related PRs together for consistency.
```

---

## Creating Groups: Detailed Guide

### Method 1: Single Commit (Manual)

**When to use:**
- Small, focused changes
- All changes made at once
- No incremental development needed

**How:**
```bash
git checkout -b feature/quick-fix

# Make all changes
vim packages/auth/handler.go
vim packages/api/middleware.go

# Create all changesets at once
changeset add
# Select: auth, api
# Bump: patch
# Message: "Fix session handling across auth and api"

# Single commit
git add .
git commit -m "fix: session handling in auth and api"

# Push and merge
git push origin feature/quick-fix
gh pr create --title "Fix session handling"
# Merge with any strategy (squash/merge/rebase)
# Already one commit â†’ already grouped! âœ…
```

---

### Method 2: Squash Merge (Automatic - Recommended)

**When to use:**
- Complex features
- Incremental development
- Multiple iterations during review
- Most common workflow

**How:**
```bash
git checkout -b feature/oauth2

# Day 1: Auth implementation
vim packages/auth/oauth.go
changeset add  # Select: auth
git commit -m "feat(auth): implement OAuth2 base"

# Day 2: API endpoints
vim packages/api/handlers.go
changeset add  # Select: api
git commit -m "feat(api): add OAuth2 endpoints"

# Day 3: After review feedback
vim packages/auth/oauth.go  # Address feedback
git commit -m "fix(auth): handle edge case"

# Day 4: Shared types
vim packages/shared/types.go
changeset add  # Select: shared
git commit -m "feat(shared): add OAuth2 types"

# Feature branch now has 4 commits, 3 changesets
git push origin feature/oauth2
gh pr create --title "Add OAuth2 support"

# After review, merge PR with SQUASH
# GitHub: "Squash and merge" button
# Result on main: ONE commit with all 3 changesets â†’ grouped! âœ…
```

**Before squash (feature branch):**
```
feature/oauth2:
  commit1: auth changeset created
  commit2: api changeset created
  commit3: (no changeset)
  commit4: shared changeset created
```

**After squash (main branch):**
```
main:
  commit e810ecb: ALL 3 changesets created
  
Result: auth, api, shared changesets all in ONE commit â†’ grouped!
```

**Critical:** Must use **squash merge** when merging to main!

---

### Method 3: Manual Grouping (Advanced)

For advanced workflows where you need precise control:

```bash
# Create changesets individually during development
# (on feature branch, different commits)

# Before merging to main, manually combine them
git checkout feature/oauth2

# Amend all changesets into one commit
git add .changeset/
git commit --amend -m "feat: add OAuth2 support (multi-project)"

# Or create a new commit with all changesets
git reset --soft HEAD~3  # Undo last 3 commits
git add .changeset/
git commit -m "feat: add OAuth2 support (multi-project)"

# Push
git push origin feature/oauth2 --force

# Merge to main
# Result: Changesets in one commit â†’ grouped âœ…
```

**Use sparingly** - squash merge is simpler!

---

## Squash Merge: Deep Dive

### Why Squash Merge is Critical

**With Squash Merge (Recommended):**
```bash
Feature branch: 10 commits
Changesets: Created in commits 1, 5, and 9

Merge to main (squash):
  main: 1 commit containing all changesets
  
changeset tree:
  Commit: abc1234 (feat: ...)
  â”œâ”€ auth
  â”œâ”€ api
  â””â”€ shared
  
Result: Grouped! âœ…
```

**Without Squash Merge (Merge Commit):**
```bash
Feature branch: 10 commits
Changesets: Created in commits 1, 5, and 9

Merge to main (merge commit):
  main: 11 commits (original 10 + merge commit)
  Changeset commits: 1, 5, 9 (still separate!)
  
changeset tree:
  Commit: commit1 (...)
  â””â”€ auth
  
  Commit: commit5 (...)
  â””â”€ api
  
  Commit: commit9 (...)
  â””â”€ shared
  
Result: NOT grouped! âŒ
```

### Configuring GitHub for Squash Merge

**Repository Settings:**
```
Settings > General > Pull Requests

Merge button options:
âœ… Allow squash merging (ENABLE - recommended)
â˜ Allow merge commits (optional)
â˜ Allow rebase merging (optional)

Default behavior:
â€¢ Set "Squash merging" as default
```

**Per-PR Override:**
```
When merging a PR, you can choose:
- "Squash and merge" â† Use this for changeset grouping
- "Create a merge commit"
- "Rebase and merge"
```

**Recommendation:** Set squash as default, use others only when needed.

---

## Troubleshooting

### Changesets Not Grouped as Expected

**Symptom:**
```bash
$ changeset tree
# Shows changesets in separate groups when they should be together
```

**Cause 1: Used merge commit instead of squash**
```bash
# Check git history
git log --oneline main | head -5

# If you see multiple commits from the feature branch,
# you used merge commit, not squash
```

**Solution:** Use squash merge for future PRs

**Cause 2: Changesets created in different commits**
```bash
git log --all -- .changeset/oauth-auth.md
git log --all -- .changeset/oauth-api.md

# Different commit SHAs â†’ not grouped
```

**Solution:** Squash merge the PR to combine them

---

### "Unknown" Commit Group

**Symptom:**
```bash
Ungrouped changesets (not in git history):
â””â”€ auth: my-changeset.md
```

**Cause:** Changeset file not yet committed to git

**Solution:**
```bash
# Commit the changeset
git add .changeset/
git commit -m "Add changeset"

# Now tree will show the commit
```

---

### Tree Shows Too Many Groups

**Symptom:** Every changeset in its own group

**Cause:** Each changeset added in a separate commit, no squash merge used

**Solution:** 
```bash
# Option 1: Enable squash merge for future PRs
# Option 2: Manually combine changesets before releasing:

git checkout -b combine-changesets

# Reset to before changesets were added
git log --oneline  # Find base commit
git reset --soft abc1234  # Base commit SHA

# Re-commit all changesets together
git add .changeset/
git commit -m "chore: combine related changesets"
git push --force
```

---

### PR Linking Doesn't Work

**Symptom:** Related PRs created but no relationship section appears

**Checks:**
```yaml
# 1. Is jq installed? (Should be in GitHub Actions)
- run: which jq

# 2. Was tree.json created?
- run: ls -la /tmp/tree.json

# 3. Was pr-mapping.txt created?
- run: cat /tmp/pr-mapping.txt

# 4. Check workflow logs for errors in "Link related PRs" step
```

**Solutions:**
- Ensure tree step runs before version step
- Check jq is available (pre-installed in GitHub Actions)
- Verify GH_TOKEN has permissions

---

## Advanced Usage

### Previewing Groups Before Merging

Before merging your feature PR, preview how changesets will be grouped:

```bash
# On your feature branch
git checkout feature/oauth2

# Check current grouping (before squash)
changeset tree

# Shows: Multiple groups (one per commit where changeset created)

# After squash merge, will be: One group (all changesets together)
```

**Use this to verify:**
- All intended changesets are present
- Commit messages are descriptive
- Grouping will be correct after squash

### Manually Inspecting Groups

```bash
# Get commit SHA for a specific changeset
git log --follow --diff-filter=A --pretty=format:"%H" -1 .changeset/oauth-auth.md
# â†’ e810ecb51bbded25f24faf9fe3da368fc01fcef7

# Find all changesets from that commit
git diff-tree --no-commit-id --name-only -r e810ecb | grep "\.changeset/"
# â†’ .changeset/oauth-auth.md
# â†’ .changeset/oauth-api.md
# â†’ .changeset/oauth-shared.md
```

### JSON Processing Examples

**Count groups:**
```bash
changeset tree --format json | jq '.groups | length'
```

**List all projects with changesets:**
```bash
changeset tree --format json | jq -r '.groups[].projects[].name' | sort -u
```

**Find largest group:**
```bash
changeset tree --format json | jq '.groups | max_by(.projects | length)'
```

**Filter to specific project:**
```bash
changeset tree --format json | jq '.groups[] | select(.projects[].name == "auth")'
```

---

## Migration Guide

### If You're Already Using go-changeset

The tree command works retroactively! Your existing changesets will be grouped based on their creation commits.

**To see current groupings:**
```bash
changeset tree --filter open-changesets
```

**To enable PR linking:**
1. Update your workflow to include the 3-step process (see kitchensink example)
2. Tree analysis, PR creation, PR linking
3. That's it!

**No changeset migration needed** - everything is based on git history.

---

## Comparison: Grouped vs Ungrouped

| Aspect | Grouped (Recommended) | Ungrouped |
|--------|----------------------|-----------|
| **Creation** | One commit or squash merge | Multiple commits, no squash |
| **Review** | Coordinated review | Independent review |
| **Merge** | All together | Any order |
| **Risk** | Low (complete feature) | High (partial release) |
| **Visibility** | Clear relationships | Hidden dependencies |
| **PR Body** | Shows related PRs | No relationships shown |

---

## FAQ

**Q: Do I have to use squash merge?**

A: No, but it's highly recommended for changesets that should be grouped. If you use merge commits or rebase, changesets will remain in separate groups.

**Q: Can I manually override grouping?**

A: Currently, grouping is automatic based on git commits. Manual grouping via frontmatter may be added in the future.

**Q: What if I forget to squash merge?**

A: The changesets will be in separate groups. You can:
- Manually note the relationships in PR descriptions
- Still merge the PRs together (just not automatically linked)
- Use `changeset tree` to see the actual grouping

**Q: Can one changeset be in multiple groups?**

A: No - each changeset has exactly one creation commit, so it belongs to exactly one group.

**Q: What happens to groups after versioning?**

A: After `changeset version` deletes the files, the group information is lost. That's why `changeset tree` must be run **before** versioning (Step 1 in the workflow).

**Q: Can I disable PR linking?**

A: Yes - simply remove or skip the "Link related PRs" step in your workflow. The tree command still works for manual review.

**Q: Does tree work with filters?**

A: Yes - same filters as `each` command:
```bash
changeset tree --filter open-changesets
changeset tree --filter has-version
changeset tree --filter all
```

---

## Examples

### Example 1: Viewing Before Release

```bash
# Before creating release PRs, check relationships
$ changeset tree

ðŸ“Š Changeset Relationship Tree

Commit: e810ecb (feat: add OAuth2 support)
â”œâ”€ auth (1 changeset(s))
â”œâ”€ api (1 changeset(s))
â””â”€ shared (1 changeset(s))

# Decision: These 3 PRs should be reviewed together
```

### Example 2: Using in Scripts

```bash
# Get all projects in the largest group
LARGEST_GROUP=$(changeset tree --format json | \
  jq -r '.groups | max_by(.projects | length) | .projects[].name')

echo "Largest group affects: $LARGEST_GROUP"
```

### Example 3: Documentation

```bash
# Generate release coordination notes
changeset tree > release-coordination.txt

# Share with team:
# "These PRs are related, please review together: ..."
```

---

## Summary

**To create related changesets that will be grouped:**

1. âœ… **Recommended:** Use `changeset add` to select multiple projects at once
2. âœ… **Recommended:** Use squash merge when merging feature PRs to main
3. âœ… Use `changeset tree` to verify grouping before releasing
4. âœ… Enable PR linking in your workflow (optional but helpful)

**Key Principle:** One commit = one group. Either create changesets together or use squash merge to combine them.

---

**Continue to:**
- [GitHub Integration](./github-integration.mdx) for complete workflow setup
- [Snapshot Releases](./snapshotting.mdx) for RC testing workflows
- [Introduction to Changesets](./intro-to-using-changesets.mdx) for core concepts
